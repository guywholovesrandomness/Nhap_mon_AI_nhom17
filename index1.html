<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Map Pro</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        body { margin: 0; display: flex; height: 100vh; font-family: 'Segoe UI', sans-serif; }
        .sidebar { width: 340px; background: #fff; border-right: 1px solid #ddd; padding: 15px; display: flex; flex-direction: column; gap: 10px; overflow-y: auto; z-index: 1000; box-shadow: 2px 0 5px rgba(0,0,0,0.1); }
        h2 { margin: 0; color: #0056b3; font-size: 18px; display: flex; align-items: center; gap: 5px;}
        
        .box { background: #f8f9fa; padding: 12px; border-radius: 6px; border: 1px solid #e9ecef; margin-bottom: 5px; }
        .box.rain { background: #e3f2fd; border-color: #b3d7ff; }
        .box.traffic { background: #fff3cd; border-color: #ffeeba; }
        
        .lbl { font-size: 12px; font-weight: bold; color: #555; display: block; margin-bottom: 4px; }
        .row { display: flex; gap: 5px; align-items: center; }
        
        input[type="text"] { flex: 1; padding: 6px; border: 1px solid #ced4da; border-radius: 4px; font-size: 13px;}
        input[type="number"] { padding: 6px; width: 60px; border: 1px solid #ced4da; border-radius: 4px; font-size: 13px;}
        
        button { padding: 8px; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 12px; transition: 0.2s; }
        .btn-blue { background: #17a2b8; color: white; }
        .btn-green { background: #28a745; color: white; width: 100%; margin-top: 5px; font-size: 14px; } .btn-green:disabled { background: #ccc; }
        .btn-update { background: #007aff; color: white; flex: 1; }
        .btn-danger { background: #dc3545; color: white; width: 100%; margin-top: 5px; }
        .btn-reset { background: #6c757d; color: white; width: 100%; margin-top: 5px; }
        .btn-visual { background: #20c997; color: white; width: 100%; margin-top: 5px; }
        

        .mode-group { display: flex; gap: 2px; margin-top: 5px; }
        .mode-btn { flex: 1; border: 1px solid #ccc; background: #fff; color: #333; font-size: 11px; padding: 6px 2px;}
        .mode-btn.active-route { background: #28a745; color: white; border-color: #28a745; }
        .mode-btn.active-traffic { background: #ffc107; color: #000; border-color: #ffc107; }
        .mode-btn.active-forbidden { background: #343a40; color: white; border-color: #343a40; }
        
        .status { padding: 8px; background: #e9ecef; border-radius: 4px; font-size: 12px; text-align: center; font-weight: 500;}
        .chk-row { display: flex; align-items: center; gap: 5px; font-size: 12px; margin-top: 5px;}
    </style>
</head>
<body>
    <div class="sidebar">
        <h2>üó∫Ô∏è Smart Map Pro</h2>

        <div class="box">
            <span class="lbl">üìç T√¨m ƒë∆∞·ªùng</span>
            <div style="margin-bottom: 5px;">
                <div style="margin-bottom: 10px;">
                    <span class="lbl">Ph∆∞∆°ng ti·ªán:</span>
                    <select id="vehicleType" style="width: 100%; padding: 5px;">
                        <option value="walk">üö∂ ƒêi b·ªô (5 km/h)</option>
                        <option value="motorbike" selected>üèçÔ∏è Xe m√°y (25 km/h)</option>
                        <option value="car">üöó √î t√¥ (35 km/h)</option>
                    </select>
                </div>                
                <div class="row"><input id="startAddr" type="text" placeholder="ƒêi·ªÉm ƒëi..."><button class="btn-blue" onclick="searchLoc('start')">üîç</button></div>
                <div id="startCoord" style="font-size: 10px; color: #777;">Ch∆∞a ch·ªçn</div>
            </div>
            <div>
                <div class="row"><input id="endAddr" type="text" placeholder="ƒêi·ªÉm ƒë·∫øn..."><button class="btn-blue" onclick="searchLoc('end')">üîç</button></div>
                <div id="endCoord" style="font-size: 10px; color: #777;">Ch∆∞a ch·ªçn</div>
            </div>
            <button id="findBtn" class="btn-green" onclick="findPath()" disabled>üöÄ T√¨m ƒë∆∞·ªùng</button>
            <button class="btn-reset" onclick="resetAll()">üîÑ Reset</button>
        </div>

        <div class="box rain">
            <span class="lbl" style="color:#0056b3">‚òî Ng·∫≠p l·ª•t & An to√†n</span>
            <div class="row">
                <input id="rainInput" type="number" placeholder="mm" value="0">
                <span>mm</span>
                <button class="btn-update" onclick="setRain()">C·∫≠p nh·∫≠t</button>
            </div>
            <button class="btn-visual" onclick="showSafeRoads()">üëÅÔ∏è Xem ƒë∆∞·ªùng ƒëi ƒë∆∞·ª£c</button>
        </div>

        <div class="box traffic">
            <span class="lbl" style="color:#856404">üõ†Ô∏è C√¥ng c·ª• B·∫£n ƒë·ªì</span>
            <div class="row">
                <span style="font-size: 12px;">ƒê·ªô t·∫Øc:</span>
                <select id="trafficLevel" style="flex:1; padding:6px; border:1px solid #ced4da; border-radius:4px; font-size:13px;">
                    <option value="light">ƒê√¥ng (x1.2)</option>
                    <option value="medium">T·∫Øc v·ª´a (x1.5)</option>
                    <option value="heavy">T·∫Øc n·∫∑ng (x2.0)</option>
                </select>
            </div>
            
            <div class="mode-group">
                <button id="btnRoute" class="mode-btn active-route" onclick="setMode('route')">üìç Ch·ªçn</button>
                <button id="btnTraffic" class="mode-btn" onclick="setMode('traffic')">‚ö†Ô∏è T·∫Øc</button>
                <button id="btnForbidden" class="mode-btn" onclick="setMode('forbidden')">‚õî C·∫•m</button>
            </div>

            <div style="display: flex; gap: 5px;">
                <button class="btn-danger" style="background: #ffc107; color: #000" onclick="clearData('traffic')">X√≥a T·∫Øc</button>
                <button class="btn-danger" style="background: #343a40;" onclick="clearData('forbidden')">X√≥a C·∫•m</button>
            </div>
        </div>

        <div class="chk-row">
            <input type="checkbox" id="showNodes"> <label for="showNodes">Hi·ªán Nodes</label>
        </div>
        <div class="status" id="status">S·∫µn s√†ng.</div>
    </div>
    
    <div id="map" style="flex-grow: 1;"></div>

    <script>
        const map = L.map('map').setView([20.9764, 105.8556], 15);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '¬© OSM' }).addTo(map);

        let startMarker, endMarker, pathLayer;
        let trafficLayer = L.layerGroup().addTo(map);
        let forbiddenLayer = L.layerGroup().addTo(map); 
        let safeRoadsLayer = L.layerGroup().addTo(map);
        let nodesLayer = L.layerGroup();
        
        let startLL = null, endLL = null;
        let mode = 'route'; 
        let selectTarget = 'start';
        const statusEl = document.getElementById('status');
        const findBtn = document.getElementById('findBtn');
        const showNodesChk = document.getElementById('showNodes');

        // Icon cho c√°c lo·∫°i pin
        const redIcon = L.icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34]
        });

        const blackIcon = L.icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-black.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34]
        });


        let trafficStartLL = null, trafficEndLL = null;
        let trafficStartMarker = null, trafficEndMarker = null;
        let forbiddenStartLL = null, forbiddenEndLL = null;
        let forbiddenStartMarker = null, forbiddenEndMarker = null;


        map.on('click', e => {
            if (mode === 'route') {
                if (pathLayer) resetAll();
                if (selectTarget === 'start') { 
                    setPt('start', e.latlng, "Click map"); 
                    selectTarget = 'end'; 
                } else { 
                    setPt('end', e.latlng, "Click map"); 
                    selectTarget = 'start'; 
                }
            } else if (mode === 'traffic') {
                handleTrafficClick(e.latlng);
            } else if (mode === 'forbidden') {
                handleForbiddenClick(e.latlng);
            }
        });


        function setPt(type, ll, label) {
            const elCoord = document.getElementById(type+'Coord');
            const elAddr = document.getElementById(type+'Addr');
            
            if (type === 'start') {
                if (startMarker) map.removeLayer(startMarker);
                startMarker = L.marker(ll).addTo(map).bindPopup("A").openPopup();
                startLL = ll;
            } else {
                if (endMarker) map.removeLayer(endMarker);
                endMarker = L.marker(ll, {icon: redIcon}).addTo(map).bindPopup("B").openPopup();
                endLL = ll;
            }
            elCoord.innerText = `${ll.lat.toFixed(5)}, ${ll.lng.toFixed(5)}`;
            if (label !== "Click map") elAddr.value = label;
            findBtn.disabled = !(startLL && endLL);
        }


async function findPath() {
    if (!startLL || !endLL) return;
    

    const vType = document.getElementById('vehicleType').value;
    const statusEl = document.getElementById('status'); 
    
    statusEl.innerText = "ƒêang t√≠nh to√°n...";
    if (typeof pathLayer !== 'undefined' && pathLayer) map.removeLayer(pathLayer);

    try {
        const res = await fetch('http://localhost:5000/api/find-path', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                start: startLL,
                end: endLL,
                vehicle: vType 
            })
        });
        
        const data = await res.json();
        if (data.status === 'success') {
            
            if (pathLayer) map.removeLayer(pathLayer); 


            if (vType === 'car') {
                const color = 'blue';
                const dashStyle = {color: color, weight: 5, opacity: 0.7, dashArray: '10, 10'}; // N√©t ƒë·ª©t cho ƒëi b·ªô
                const solidStyle = {color: color, weight: 5, opacity: 0.9}; // N√©t li·ªÅn cho l√°i xe


                pathLayer = L.layerGroup(); 

                // 1. V·∫Ω ƒëo·∫°n ƒëi b·ªô ƒë·∫ßu (n√©t ƒë·ª©t)
                if (data.path1_walk && data.path1_walk.length > 0) {
                    L.polyline(data.path1_walk, dashStyle).addTo(pathLayer);
                }

                // 2. V·∫Ω ƒëo·∫°n l√°i xe (n√©t li·ªÅn)
                if (data.path2_drive && data.path2_drive.length > 0) {
                    L.polyline(data.path2_drive, solidStyle).addTo(pathLayer);
                }

                // 3. V·∫Ω ƒëo·∫°n ƒëi b·ªô cu·ªëi (n√©t ƒë·ª©t)
                if (data.path3_walk && data.path3_walk.length > 0) {
                    L.polyline(data.path3_walk, dashStyle).addTo(pathLayer);
                }

                pathLayer.addTo(map);
            } else {
                // X·ª≠ l√Ω cho xe m√°y / ƒëi b·ªô 
                let color = 'lime'; 
                pathLayer = L.polyline(data.path, {color: color, weight: 5}).addTo(map);
            }
            
            if (pathLayer) {
                try {
                    const bounds = pathLayer.getBounds();
                    if (bounds.isValid()) {
                        map.fitBounds(bounds);
                    }
                } catch (e) {
                    console.warn("Could not fit map bounds. Path might be too short or invalid.", e);
                }
            }
            

            let msg = `‚úÖ Xong!\n‚è±Ô∏è Th·ªùi gian: ${data.time} ph√∫t\nüìè Qu√£ng ƒë∆∞·ªùng: ${(data.distance/1000).toFixed(2)} km`;
            if(data.details && data.details.length > 0) {
                msg += `\n---\n${data.details.join('\n')}`;
            }
            statusEl.innerText = msg;
        } else {
            statusEl.innerText = "L·ªói: " + data.message;
        }
    } catch(e) {
        console.error(e);
        statusEl.innerText = "L·ªói k·∫øt n·ªëi server.";
    }
}
async function showSafeRoads() {

    const rainVal = document.getElementById('rainInput').value;

    await fetch('http://localhost:5000/api/set-rain', {
        method: 'POST', 
        headers: {'Content-Type':'application/json'}, 
        body: JSON.stringify({rain: rainVal})
    });
    

    if (showNodesChk.checked) {
        showNodesChk.checked = false;
        nodesLayer.clearLayers();
    }

    statusEl.textContent = `ƒêang t·∫£i d·ªØ li·ªáu v·ªõi m·ª©c m∆∞a ${rainVal}mm...`;
    try {
        const res = await fetch('http://localhost:5000/api/safe-roads');
        const d = await res.json();

        safeRoadsLayer.clearLayers(); 

        const flooded = d.flooded_roads || [];
        

        if (flooded.length === 0) {
            statusEl.textContent = "‚úÖ Kh√¥ng c√≥ ƒë∆∞·ªùng n√†o b·ªã ng·∫≠p v·ªõi l∆∞·ª£ng m∆∞a n√†y.";
            statusEl.style.color = "green";
            return;
        }


        const allLatLngs = [];
        flooded.forEach(line => {
            L.polyline(line, {
                color: '#0066ff',   // M√†u ƒë·ªè t∆∞∆°i c·∫£nh b√°o
                weight: 4,          // D√†y h∆°n ch√∫t cho d·ªÖ nh√¨n
                opacity: 0.8,
            }).addTo(safeRoadsLayer);
            allLatLngs.push(...line);
        });

        if (allLatLngs.length > 0) {
            map.fitBounds(allLatLngs, { padding: [40, 40] });
        }

        statusEl.textContent = `‚ö†Ô∏è C√≥ ${flooded.length} ƒëo·∫°n ƒë∆∞·ªùng b·ªã NG·∫¨P!`;
        statusEl.style.color = "red";

    } catch (e) {
        console.error(e);
        statusEl.textContent = "L·ªói t·∫£i d·ªØ li·ªáu ng·∫≠p l·ª•t.";
    }
}

        function setMode(m) {
            mode = m;
            document.getElementById('btnRoute').className = m==='route'?'mode-btn active-route':'mode-btn';
            document.getElementById('btnTraffic').className = m==='traffic'?'mode-btn active-traffic':'mode-btn';
            document.getElementById('btnForbidden').className = m==='forbidden'?'mode-btn active-forbidden':'mode-btn';
            
            if(m==='route') map.getContainer().style.cursor='crosshair';
            else if(m==='traffic') map.getContainer().style.cursor='copy'; 
            else map.getContainer().style.cursor='not-allowed'; // Icon c·∫•m
            
            const txt = {
                'route':'Ch·ªçn ƒëi·ªÉm ƒëi/ƒë·∫øn',
                'traffic':'Click 2 ƒëi·ªÉm (ƒë·∫ßu & cu·ªëi) c·ªßa ƒëo·∫°n ƒë∆∞·ªùng t·∫Øc',
                'forbidden':'Click 2 ƒëi·ªÉm (ƒë·∫ßu & cu·ªëi) c·ªßa ƒëo·∫°n ƒë∆∞·ªùng C·∫§M'
            };
            statusEl.textContent = txt[m];
        }

        async function clearData(type) {
            const api = type==='traffic'?'/api/clear-traffic':'/api/clear-forbidden';
            const layer = type==='traffic'?trafficLayer:forbiddenLayer;
            if(confirm(`X√≥a h·∫øt d·ªØ li·ªáu ${type}?`)) {
                await fetch('http://localhost:5000'+api, {method:'POST'});
                layer.clearLayers();

                if (type === 'traffic') {
                    trafficStartLL = trafficEndLL = null;
                    trafficStartMarker = trafficEndMarker = null;
                } else {
                    forbiddenStartLL = forbiddenEndLL = null;
                    forbiddenStartMarker = forbiddenEndMarker = null;
                }

                statusEl.textContent = `ƒê√£ x√≥a ${type}.`;
            }
        }
        function resetAll() {

            if (startMarker) { map.removeLayer(startMarker); startMarker = null; }
            if (endMarker) { map.removeLayer(endMarker); endMarker = null; }
            

            if (pathLayer) { 
                map.removeLayer(pathLayer); 
                pathLayer = null; 
            }
            

            startLL = null; 
            endLL = null;

            document.getElementById('startAddr').value = "";
            document.getElementById('endAddr').value = "";
            document.getElementById('startCoord').innerText = "Ch∆∞a ch·ªçn";
            document.getElementById('endCoord').innerText = "Ch∆∞a ch·ªçn";
            

            const vehicleSelect = document.getElementById('vehicleType');
            if(vehicleSelect) vehicleSelect.value = "motorbike"; 

            const resultBox = document.getElementById('resultBox'); 
            if(resultBox) resultBox.style.display = 'none';
            
            document.getElementById('status').innerText = "S·∫µn s√†ng.";

            findBtn.disabled = true;
        }

        function handleTrafficClick(ll) {
            if (!trafficStartLL) {
                trafficStartLL = ll;
                if (trafficStartMarker) trafficLayer.removeLayer(trafficStartMarker);
                trafficStartMarker = L.marker(ll, {icon: redIcon})
                    .addTo(trafficLayer)
                    .bindPopup("ƒê·∫ßu ƒëo·∫°n t·∫Øc")
                    .openPopup();
                statusEl.textContent = "ƒê√£ ch·ªçn ƒëi·ªÉm ƒë·∫ßu. Ch·ªçn ti·∫øp ƒëi·ªÉm cu·ªëi c·ªßa ƒëo·∫°n t·∫Øc.";
            } else if (!trafficEndLL) {
                trafficEndLL = ll;
                if (trafficEndMarker) trafficLayer.removeLayer(trafficEndMarker);
                trafficEndMarker = L.marker(ll, {icon: redIcon})
                    .addTo(trafficLayer)
                    .bindPopup("Cu·ªëi ƒëo·∫°n t·∫Øc")
                    .openPopup();
                addTrafficSegment();
            } else {

                if (trafficStartMarker) trafficLayer.removeLayer(trafficStartMarker);
                if (trafficEndMarker) trafficLayer.removeLayer(trafficEndMarker);
                
                trafficStartLL = ll;
                trafficEndLL = null;
                trafficStartMarker = L.marker(ll, {icon: redIcon})
                    .addTo(trafficLayer)
                    .bindPopup("ƒê·∫ßu ƒëo·∫°n t·∫Øc")
                    .openPopup();
                statusEl.textContent = "ƒê√£ reset ƒëo·∫°n t·∫Øc, h√£y ch·ªçn ƒëi·ªÉm cu·ªëi m·ªõi.";
            }
        }

        async function addTrafficSegment() {
            if (!trafficStartLL || !trafficEndLL) return;
            const level = document.getElementById('trafficLevel').value || 'light';
            statusEl.textContent = "ƒêang ghi nh·∫≠n ƒëo·∫°n ƒë∆∞·ªùng t·∫Øc...";

            try {
                const res = await fetch('http://localhost:5000/api/add-traffic', {
                    method:'POST',
                    headers:{'Content-Type':'application/json'},
                    body: JSON.stringify({
                        start: trafficStartLL,
                        end: trafficEndLL,
                        level
                    })
                });
                const d = await res.json();
                if (d.status === 'success') {
                    const color = d.color || (level === 'medium' ? '#ff7f00' : (level === 'heavy' ? '#ff0000' : '#ffd000'));
                    L.polyline(d.path, {color: color, weight: 5, opacity: 0.9}).addTo(trafficLayer);
                    statusEl.textContent = "ƒê√£ th√™m ƒëo·∫°n ƒë∆∞·ªùng t·∫Øc.";
                } else {
                    alert(d.message || 'Kh√¥ng th√™m ƒë∆∞·ª£c ƒëo·∫°n t·∫Øc');
                    statusEl.textContent = "‚ùå Kh√¥ng th√™m ƒë∆∞·ª£c ƒëo·∫°n t·∫Øc.";
                }
            } catch(e) {
                console.error(e);
                statusEl.textContent = "L·ªói k·∫øt n·ªëi server khi th√™m ƒëo·∫°n t·∫Øc.";
            } finally {

                if (trafficStartMarker) trafficLayer.removeLayer(trafficStartMarker);
                if (trafficEndMarker) trafficLayer.removeLayer(trafficEndMarker);
                
                trafficStartLL = null;
                trafficEndLL = null;
                trafficStartMarker = null;
                trafficEndMarker = null;
            }
        }


        function handleForbiddenClick(ll) {
            if (!forbiddenStartLL) {
                forbiddenStartLL = ll;
                if (forbiddenStartMarker) forbiddenLayer.removeLayer(forbiddenStartMarker);
                forbiddenStartMarker = L.marker(ll, {icon: blackIcon})
                    .addTo(forbiddenLayer)
                    .bindPopup("ƒê·∫ßu ƒëo·∫°n C·∫§M")
                    .openPopup();
                statusEl.textContent = "ƒê√£ ch·ªçn ƒëi·ªÉm ƒë·∫ßu ƒë∆∞·ªùng c·∫•m. Ch·ªçn ti·∫øp ƒëi·ªÉm cu·ªëi.";
            } else if (!forbiddenEndLL) {
                forbiddenEndLL = ll;
                if (forbiddenEndMarker) forbiddenLayer.removeLayer(forbiddenEndMarker);
                forbiddenEndMarker = L.marker(ll, {icon: blackIcon})
                    .addTo(forbiddenLayer)
                    .bindPopup("Cu·ªëi ƒëo·∫°n C·∫§M")
                    .openPopup();
                addForbiddenSegment();
            } else {

                if (forbiddenStartMarker) forbiddenLayer.removeLayer(forbiddenStartMarker);
                if (forbiddenEndMarker) forbiddenLayer.removeLayer(forbiddenEndMarker);

                forbiddenStartLL = ll;
                forbiddenEndLL = null;
                forbiddenStartMarker = L.marker(ll, {icon: blackIcon})
                    .addTo(forbiddenLayer)
                    .bindPopup("ƒê·∫ßu ƒëo·∫°n C·∫§M")
                    .openPopup();
                statusEl.textContent = "ƒê√£ reset ƒëo·∫°n c·∫•m, h√£y ch·ªçn ƒëi·ªÉm cu·ªëi m·ªõi.";
            }
        }

        async function addForbiddenSegment() {
            if (!forbiddenStartLL || !forbiddenEndLL) return;
            statusEl.textContent = "ƒêang ghi nh·∫≠n ƒëo·∫°n ƒë∆∞·ªùng C·∫§M...";
            try {
                const res = await fetch('http://localhost:5000/api/add-forbidden', {
                    method:'POST',
                    headers:{'Content-Type':'application/json'},
                    body: JSON.stringify({
                        start: forbiddenStartLL,
                        end: forbiddenEndLL
                    })
                });
                const d = await res.json();
                if (d.status === 'success') {
                    L.polyline(d.path, {color: '#000000', weight: 5, opacity: 0.9}).addTo(forbiddenLayer);
                    statusEl.textContent = "ƒê√£ ƒë√°nh d·∫•u ƒëo·∫°n ƒë∆∞·ªùng C·∫§M.";
                } else {
                    alert(d.message || 'Kh√¥ng th√™m ƒë∆∞·ª£c ƒë∆∞·ªùng c·∫•m');
                    statusEl.textContent = "‚ùå Kh√¥ng th√™m ƒë∆∞·ª£c ƒë∆∞·ªùng c·∫•m.";
                }
            } catch(e) {
                console.error(e);
                statusEl.textContent = "L·ªói k·∫øt n·ªëi server khi th√™m ƒë∆∞·ªùng c·∫•m.";
            } finally {

                if (forbiddenStartMarker) forbiddenLayer.removeLayer(forbiddenStartMarker);
                if (forbiddenEndMarker) forbiddenLayer.removeLayer(forbiddenEndMarker);
                
                forbiddenStartLL = null;
                forbiddenEndLL = null;
                forbiddenStartMarker = null;
                forbiddenEndMarker = null;
            }
        }


        async function setRain() {
            const r = document.getElementById('rainInput').value;
            await fetch('http://localhost:5000/api/set-rain', {
                method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({rain:r})
            });
            statusEl.textContent = "ƒê√£ c·∫≠p nh·∫≠t m∆∞a.";
        }

        async function searchLoc(type) {
            const q = document.getElementById(type+'Addr').value;
            if(!q) return;
            const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}&limit=1`);
            const d = await res.json();
            if(d.length) {
                const ll = {lat:parseFloat(d[0].lat), lng:parseFloat(d[0].lon)};
                if(pathLayer) resetAll();
                setPt(type, ll, d[0].display_name);
                map.setView(ll, 16);
            } else alert("Kh√¥ng t√¨m th·∫•y");
        }

        showNodesChk.addEventListener('change', async function() {
            if(this.checked) {
                safeRoadsLayer.clearLayers(); 
                const res = await fetch('http://localhost:5000/api/all-nodes');
                const d = await res.json();
                d.nodes.forEach(n => L.circleMarker(n, {radius:2, color:'blue', opacity:0.3}).addTo(nodesLayer));
                nodesLayer.addTo(map);
            } else nodesLayer.clearLayers();
        });

        setMode('route'); 
    </script>
</body>
</html>
